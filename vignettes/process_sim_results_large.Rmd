---
title: "process_sim_results_large"
output:
  html_document: 
    toc: true
    toc_float: true
    code_folding: hide
hitheme: tomorrow
highlighter: highlight.js
date: "2026-02-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
```

```{r}
library(KAMP)
library(tidyverse)
library(spatstat.random)
library(microbenchmark)
library(spatstat.geom)
library(spatstat.explore)
library(ggplot2)
library(Rcpp)
library(kableExtra)
library(parallel)
library(here)
library(patchwork)
set.seed(50)
```

# TODOS
- Code profiling 
- Simulation studies
- Cleaning up code, comments
- Continued edits to vignettes, README, and function documentation
- Help files
- Edit unit tests


# Progress

## Larger simulation study:

- n = (500, 1000, 5000)
- Abundance = (0.1, 0.3)
- clust = (TRUE, FALSE)
- correction = (trans, iso)
- Bivariate inhomogenous
- reps = 100
- nperm = 1000
- Goal: compare K, Kinhom, KAMP, KAMP lite (thin_pct = 0.5), Kperm, KAMP variance, KAMP_lite variance, Kperm variance

### Analyses

- Computation time
- Degree of clustering 
- Variance: Power, Type 1 error 

### Results
- Successfully sped up KAMP by accepting a dataframe or a point process object in the main function :)

- Runtime 
  - KAMP and KAMP lite runtime were faster than K and much faster than Kperm, but was about 2x slower than Kinhom when n was larger
- Variance
  - Type 1 Error
    - Using correction = trans, KAMP type 1 error rate was pretty much the same as Kperm, while using correction = iso, KAMP type 1 error rate was lower than Kperm for smaller n and then higher than Kperm for larger n
  - Power
    - KAMP and Kperm had similar power, with KAMP_lite consistently having lower power (probably expected due to the thinning) 

# Questions + Next Steps
- Next Steps?



```{r}
num_scenarios <- 24
sim_results <- list()
for (i in 1:num_scenarios) {
  load(here("vignettes", "output_large", paste0(i, ".RDA")))
  sim_results[[i]] <- results_list
}

```

# Runtime

## Expectation
```{r, figures=TRUE, fig.width=9, fig.height=9}
runtime_long <- map_dfr(seq_along(sim_results), function(i) {
  map_dfr(seq_along(sim_results[[i]]), function(j) {
    sim_results[[i]][[j]]$times %>%
      mutate(
        scenario = i,
        rep_index = j
      )
  })
})


plot_df <- runtime_long %>%
  filter(correction == "trans", clust == FALSE) %>%
  filter(method %in% c("K","Kinhom","KAMP","KAMP_lite","Kperm")) %>%  # adjust if names differ
  mutate(n = factor(n), abundance = factor(abundance))

ggplot(plot_df, aes(x = n, y = elapsed, fill = method)) +
  geom_boxplot(position = position_dodge(width = 0.85),
               width = 0.7, outlier.alpha = 0.25) +
  facet_wrap(~ abundance, scales = "free_y") +
  scale_y_log10() +
  labs(
    title = "Runtime distribution across reps (trans, clust = FALSE)",
    x = "Sample Size (n)",
    y = "Runtime per rep (seconds, log10 scale)",
    fill = "Method"
  ) +
  theme_minimal()

ggplot(plot_df, aes(x = n, y = elapsed, fill = method)) +
  geom_boxplot(position = position_dodge(width = 0.85),
               width = 0.7, outlier.alpha = 0.25) +
  scale_y_log10() +
  labs(
    title = "Runtime distribution across reps (trans, clust = FALSE)",
    x = "Sample Size (n)",
    y = "Runtime per rep (seconds, log10 scale)",
    fill = "Method"
  ) +
  theme_minimal()

```

```{r, results='asis'}


runtime_expectation_table <- runtime_long %>% 
  filter(correction == "trans") %>%
  filter(method %in% c("K","KAMP","KAMP_lite","Kinhom","Kperm")) %>% 
  group_by(n, abundance, clust, method) %>%
  summarise(median_runtime = median(elapsed), .groups = "drop") %>% 
  mutate(
    abundance = as.character(abundance),
    clust = ifelse(as.logical(clust), "TRUE", "FALSE")
  ) %>%
  pivot_wider(
    names_from = c(abundance, clust),
    values_from = median_runtime,
    names_sep = "_"
  ) %>%
  arrange(n, method)

for (nval in c(500, 1000, 5000)) {

  tab <- runtime_expectation_table %>%
    filter(n == nval) %>%
    select(-n)

  if (nrow(tab) == 0) next

  wanted <- c("method", "0.1_TRUE", "0.1_FALSE", "0.3_TRUE", "0.3_FALSE")
  tab <- tab %>% select(any_of(wanted))

  names(tab) <- gsub("_", " ", names(tab))
  names(tab)[1] <- "Method"

  runtime_cols <- names(tab)[-1]
  abund <- sub(" .*", "", runtime_cols)
  header_counts <- table(abund)
  header <- c(" " = 1)
  for (a in names(header_counts)) 
    header[paste0("Abundance = ", a)] <- as.integer(header_counts[[a]])

  print(
    kable(tab,
          format = "html",
          digits = 3,
          caption = paste("Median Runtime (seconds) for n =", nval)) %>%
      add_header_above(header) %>%
      kable_styling(full_width = FALSE, position = "center")
  )

  cat("\n\n")
}

```

## Variance

```{r, figures=TRUE, fig.width=9, fig.height=9}

plot_df <- runtime_long %>%
  filter(correction == "trans", clust == FALSE) %>%
  filter(method %in% c("KAMP_var", "KAMP_lite_var", "Kperm_var")) %>%
  mutate(n = factor(n), abundance = factor(abundance))

ggplot(plot_df, aes(x = n, y = elapsed, fill = method)) +
  geom_boxplot(position = position_dodge(width = 0.85),
               width = 0.7, outlier.alpha = 0.25) +
  facet_wrap(~ abundance, scales = "free_y") +
  scale_y_log10() +
  labs(
    title = "Runtime distribution across reps (trans, clust = FALSE)",
    x = "Sample Size (n)",
    y = "Runtime per rep (seconds, log10 scale)",
    fill = "Method"
  ) +
  theme_minimal()

ggplot(plot_df, aes(x = n, y = elapsed, fill = method)) +
  geom_boxplot(position = position_dodge(width = 0.85),
               width = 0.7, outlier.alpha = 0.25) +
  scale_y_log10() +
  labs(
    title = "Runtime distribution across reps (trans, clust = FALSE)",
    x = "Sample Size (n)",
    y = "Runtime per rep (seconds, log10 scale)",
    fill = "Method"
  ) +
  theme_minimal()
```

```{r, results='asis'}

runtime_var_table <- runtime_long %>% 
  filter(correction == "trans") %>%
  filter(method %in% c("KAMP_var", "KAMP_lite_var", "Kperm_var")) %>%
  group_by(n, abundance, clust, method) %>%
  summarise(median_runtime = median(elapsed), .groups = "drop") %>% 
  mutate(
    abundance = as.character(abundance),
    clust = ifelse(as.logical(clust), "TRUE", "FALSE")
  ) %>%
  pivot_wider(
    names_from = c(abundance, clust),
    values_from = median_runtime,
    names_sep = "_"
  ) %>%
  arrange(n, method)

for (nval in c(500, 1000, 5000)) {

  tab <- runtime_var_table %>%
    filter(n == nval) %>%
    select(-n)

  if (nrow(tab) == 0) next

  wanted <- c("method", "0.1_TRUE", "0.1_FALSE", "0.3_TRUE", "0.3_FALSE")
  tab <- tab %>% select(any_of(wanted))

  names(tab) <- gsub("_", " ", names(tab))
  names(tab)[1] <- "Method"

  runtime_cols <- names(tab)[-1]
  abund <- sub(" .*", "", runtime_cols)
  header_counts <- table(abund)
  header <- c(" " = 1)
  for (a in names(header_counts)) 
    header[paste0("Abundance = ", a)] <- as.integer(header_counts[[a]])

  print(
    kable(tab,
          format = "html",
          digits = 3,
          caption = paste("Median Runtime (seconds) for n =", nval)) %>%
      add_header_above(header) %>%
      kable_styling(full_width = FALSE, position = "center")
  )

  cat("\n\n")
}

```


# Degree of clustering


```{r}
r0 <- 1
doc_long <- data.frame()

for (i in seq_along(sim_results)) {
  for (j in seq_along(sim_results[[i]])) {

    res <- sim_results[[i]][[j]]

    k_val        <- res$results$k %>% filter(round(r, 2) == r0) %>% pull(fundiff)
    kinhom_val   <- res$results$kinhom  %>% filter(round(r, 2) == r0) %>% pull(fundiff)
    kperm_val    <- res$results$kperm   %>% filter(round(r, 2) == r0) %>% pull(fundiff)
    kamp_val     <- res$results$kamp    %>% filter (round(r, 2) == r0) %>% pull(kamp)
    kamp_lite_val<- res$results$kamp_lite %>% filter(round(r, 2) == r0) %>% pull(kamp)
    kamp_var_val <- res$results$kamp_var %>% filter(round(r, 2) == r0) %>% pull(kamp)
    kamp_lite_var_val <- res$results$kamp_lite_var %>% filter(round(r, 2) == r0) %>% pull(kamp)
    kperm_var_val <- res$results$kperm_var %>% filter(method == "perm") %>% filter(round(r, 2) == r0) %>% pull(fundiff)

    tmp <- data.frame(
      scenario = i,
      run = j,
      r = r0,
      n = unique(res$times$n)[1],
      clust = unique(res$times$clust)[1],
      abundance = unique(res$times$abundance)[1],
      correction = unique(res$times$correction)[1],
      method = c("K", "Kinhom", "Kperm", "KAMP", "KAMP_lite", "KAMP_var", "KAMP_lite_var", "Kperm_var"),
      doc = c(k_val, kinhom_val, kperm_val, kamp_val, kamp_lite_val, kamp_var_val, kamp_lite_var_val, kperm_var_val)
    )
    

    doc_long <- rbind(doc_long, tmp)
  }
}

```


```{r}

clustering_df <- doc_long %>% filter(method %in% c("K", "KAMP", "KAMP_lite", "Kinhom", "Kperm"))

p1 <- ggplot(subset(clustering_df, clust == FALSE),
             aes(x = factor(n), y = doc, fill = method)) +
  geom_hline(yintercept = 0, linewidth = 0.4) +
  geom_boxplot(width = 0.85, size = 1, outlier.shape = NA,
               position = position_dodge(0.9)) +
  coord_cartesian(ylim = c(-0.025, 0.1)) +
  labs(
    title = "clust = FALSE",
    x = "Sample Size (n)",
    y = "Degree of clustering",
    fill = "Method"
  ) +
  theme_minimal(base_size = 14)

p2 <- ggplot(subset(clustering_df, clust == TRUE),
             aes(x = factor(n), y = doc, fill = method)) +
  geom_hline(yintercept = 0, linewidth = 0.4) +
  geom_boxplot(width = 0.85, size = 1, outlier.shape = NA,
               position = position_dodge(0.9)) +
  coord_cartesian(ylim = c(-0.1, 0.3)) +
  labs(
    title = "clust = TRUE",
    x = "Sample Size (n)",
    y = "Degree of clustering",
    fill = "Method"
  ) +
  theme_minimal(base_size = 14)

p1 

p2

```

# Variance
```{r}
r0 <- 1
alpha <- 0.05

get_p_at_r0 <- function(df, r0) {
  if (is.null(df) || nrow(df) == 0) return(NA_real_)
  df %>%
    mutate(dist = abs(r - r0)) %>%
    arrange(dist) %>%
    slice(1) %>%
    pull(pvalue)
}

p_long <- imap_dfr(sim_results, function(scn, i) {
  imap_dfr(scn, function(res, j) {
    tibble(
      scenario   = i,
      run        = j,
      n          = unique(res$times$n)[1],
      abundance  = unique(res$times$abundance)[1],
      clust      = unique(res$times$clust)[1],
      correction = unique(res$times$correction)[1],
      
      # use kperm method = "kperm approx"
      Kperm      = get_p_at_r0(res$results$kperm_var %>% filter(method == "kperm approx"), r0),
      KAMP       = get_p_at_r0(res$results$kamp_var, r0),
      KAMP_lite  = get_p_at_r0(res$results$kamp_lite_var, r0)
    ) %>%
      pivot_longer(c(Kperm, KAMP, KAMP_lite),
                   names_to = "method",
                   values_to = "pvalue") %>%
      mutate(reject = if_else(!is.na(pvalue) & pvalue <= alpha, 1L, 0L))
  })
})

alpha <- 0.05
z <- qnorm(0.975)

type1_df <- p_long %>%
  filter(clust == FALSE) %>%
  group_by(n, abundance, correction, method) %>%
  summarise(
    n_eff = sum(!is.na(pvalue)),
    type1_error = mean(reject[!is.na(pvalue)]),
    mcse = sqrt(type1_error * (1 - type1_error) / n_eff),
    ci_lower = pmax(0, type1_error - z * mcse),
    ci_upper = pmin(1, type1_error + z * mcse),
    .groups = "drop"
  )

power_df <- p_long %>%
  filter(clust == TRUE) %>%
  group_by(n, abundance, correction, method) %>%
  summarise(
    n_eff = sum(!is.na(pvalue)),
    power = mean(reject, na.rm = TRUE),
    mcse = sqrt(power * (1 - power) / n_eff),
    ci_lower = pmax(0, power - z * mcse),
    ci_upper = pmin(1, power + z * mcse),
    .groups = "drop"
  )

pd <- position_dodge(width = 0.4)

ggplot(type1_df, aes(x = factor(n), y = type1_error, color = method, group = method)) +
  geom_hline(yintercept = alpha, linetype = "dashed") +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), width = 0.15, position = pd) +
  geom_point(size = 2, position = pd) +
  facet_grid(correction ~ abundance) +
  labs(
    title = "Type I error = P(reject H0 | H0 true)",
    x = "Sample size (n)",
    y = "Type I error"
  ) +
  theme_minimal()

ggplot(power_df, aes(x = factor(n), y = power, color = method, group = method)) +
  geom_hline(yintercept = alpha, linetype = "dashed") +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), width = 0.15, position = pd) +
  geom_point(size = 2, position = pd) +
  facet_grid(correction ~ abundance) +
  labs(
    title = "Power = P(reject H0 | H1 true)",
    x = "Sample size (n)",
    y = "Power"
  ) +
  theme_minimal()
```


# Testing fixed window
```{r}
sim_data <- sim_pp_data_biv(
      lambda_n = 1000,
      abundance = 0.3,
      markvar1 = "immune1",
      markvar2 = "immune2",
      markvar3 = "background",
      distribution = "hom",
      clust = TRUE
    )

# plot sim data

df <- as_tibble(sim_data)

ggplot(df, aes(x = x, y = y, color = marks)) +
  geom_point(alpha = 0.6, size = 1) +
  coord_fixed() +
  theme_minimal() +
  labs(title = "Simulated Point Pattern",
       color = "Cell Type")

# calc num of immune1 cells in df
sum(df$marks == "immune1")
sum(df$marks == "immune2")

```
```{r}
# sim univariate data

sim_data <- sim_pp_data(
      lambda_n = 1000,
      abundance = 0.3,
      markvar1 = "immune",
      markvar2 = "background",
      distribution = "inhom",
      clust = TRUE
    )

# plot sim data

df <- as_tibble(sim_data)

ggplot(df, aes(x = x, y = y, color = marks)) +
  geom_point(alpha = 0.6, size = 1) +
  coord_fixed() +
  theme_minimal() +
  labs(title = "Simulated Point Pattern",
       color = "Cell Type")

# calc num of immune1 cells in df
sum(df$marks == "immune")

kamp(sim_data, markvar = "immune", mark1 = "immune", rvals = seq(0, 3, length.out = 10), correction = "trans")
```

