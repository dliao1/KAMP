---
title: "correction_testing"
output: html_document
date: "2025-09-09"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
devtools::load_all()

library(KAMP)
#library(devtools)
library(tidyverse)
library(spatstat.random)
library(microbenchmark)
library(spatstat.geom)
library(spatstat.explore)

library(Rcpp)

set.seed(50)
```

# Setup
Importing data
```{r}
ids <- unique(ovarian_df$sample_id)
marksvar <- "immune"

for (id in ids) {
  df_sub <- ovarian_df %>% filter(sample_id == id)
  w <- convexhull.xy(df_sub$x, df_sub$y)
  pp_obj <- ppp(df_sub$x, df_sub$y, window = w, marks = df_sub[[marksvar]])

  p <- ggplot(as_tibble(pp_obj), aes(x, y, color = marks)) +
    geom_point(size = 0.6) +
    labs(title = paste("Sample:", id)) +
    theme_minimal()

  print(p)
}
```

```{r}
ids <- unique(ovarian_df$sample_id)
df <- ovarian_df %>% filter(sample_id == ids[4])
mark_var <- "immune"
head(df)

nrow(df)
```

# Translational

## Subset to rectangle 
Manual implementation uses Rectangles right now? But that leads to spatstat and
manual implementation having different outputs.

```{r}
#df <- df %>% filter(x >= 16000 & x <= 16500 & y >= 39000 & y <= 39500)
```


## KAMP / Spatstat
```{r}
# Translational Edge
kamp(df, 
     rvals = seq(0, 100, by = 10),
     univariate = TRUE,
     mark_var = mark_var,
     mark1 = "immune")

res <- Kest(ppp(df$x, df$y,
              window = owin(c(min(df$x), max(df$x)),
                            c(min(df$y), max(df$y))),
              marks = df[[mark_var]]),
     r = seq(0, 100, by = 10),
     correction = "trans")

as.data.frame(res)
```


## R Manual
```{r}
K_trans_manual <- function(df,
                           rvals,
                           mark_var,
                           mark1) {
  x <- df$x
  y <- df$y

  n <- length(x)
  xmin <- min(x)
  xmax <- max(x)
  ymin <- min(y)
  ymax <- max(y)
  
  width  <- xmax - xmin
  height <- ymax - ymin
  areaW  <- width * height

  # pairwise geometry
  dx  <- outer(x, x, "-")
  dy  <- outer(y, y, "-")
  dij <- sqrt(dx^2 + dy^2)

  # translation weights
  overlap_w    <- pmax(0, width  - abs(dx))
  overlap_h    <- pmax(0, height - abs(dy))
  overlap_area <- overlap_w * overlap_h
  e <- matrix(0, n, n)
  pos <- overlap_area > 0
  e[pos] <- areaW  / overlap_area[pos]
  diag(e) <- 0

  Khat <- vapply(rvals, function(r) {
    sel <- (dij <= r) # off-diagonals
    areaW / (n * (n - 1)) * sum(e[sel])
  }, numeric(1))

  data.frame(
    r        = rvals,
    K_trans  = Khat,
    theo_csr = pi * rvals^2
  )
}
```

```{r}
K_trans_manual_fast <- function(df,
                                rvals,
                                mark_var = NULL,
                                mark1    = NULL) {
  x <- df$x
  y <- df$y
  
  rvals <- sort(as.numeric(rvals))
  rmax  <- max(rvals)
  
  n <- length(x)
  xmin <- min(x)
  xmax <- max(x)
  ymin <- min(y)
  ymax <- max(y)
  
  width  <- xmax - xmin
  height <- ymax - ymin
  areaW  <- width * height
  
  dx  <- outer(x, x, "-")
  dy  <- outer(y, y, "-")
  dij <- sqrt(dx^2 + dy^2)
  
  overlap_w    <- pmax(0, width  - abs(dx))
  overlap_h    <- pmax(0, height - abs(dy))
  overlap_area <- overlap_w * overlap_h
  e <- matrix(0, n, n)
  pos <- overlap_area > 0
  e[pos] <- areaW / overlap_area[pos]
  diag(e) <- 0
  
  #Flatten distances and weights to vectors instead of matrices
  dvec <- as.vector(dij)
  wvec <- as.vector(e)
  
  dvec
  
  # get rid of self-pairs and pairs outside the max radius
  keep <- (wvec > 0) & (dvec > 0) & (dvec <= rmax)
  dvec <- dvec[keep]
  wvec <- wvec[keep]
  
  # sort pairwise distances
  sorted_indices <- order(dvec)
  dvec  <- dvec[sorted_indices]
  wvec  <- wvec[sorted_indices]
  
  # cumulative sum of weights
  cumw <- cumsum(wvec)
  
  # for each r_k, how many distances are <= r_k ?
  idx  <- findInterval(rvals, dvec, rightmost.closed = TRUE)
  
  # handle r's smaller than the smallest distance
  total_w <- numeric(length(rvals))
  positive <- idx > 0
  total_w[positive] <- cumw[idx[positive]]
  
  Khat <- areaW / (n * (n - 1)) * total_w
  
  result <- data.frame(
    r        = rvals,
    K_trans  = Khat,
    theo_csr = pi * rvals^2
  )
  
  return(result)
}


```



```{r}
K_trans_manual(df,
               rvals = seq(0, 100, by = 10),
               mark_var = mark_var,
               mark1 = "immune")


K_trans_manual_fast(df,
               rvals = seq(0, 100, by = 10),
               mark_var = mark_var,
               mark1 = "immune")

as.data.frame( Kest(ppp(df$x, df$y,
                        window = owin(c(min(df$x), max(df$x)),
                                      c(min(df$y), max(df$y))),
                        marks = df[[mark_var]]),
                    r = seq(0, 100, by = 10),
                    correction = "trans"))

```


## Timing
```{r, eval = FALSE}
microbenchmark(
  kamp = {
    kamp(df, 
         rvals = seq(0, 100, by = 10),
         univariate = TRUE,
         mark_var = mark_var,
         mark1 = "immune")
  },
  manual_fast = {
    K_trans_manual_fast(df,
                         rvals = seq(0, 100, by = 10),
                         mark_var = mark_var,
                         mark1 = "immune")
  },
  manual = {
    K_trans_manual(df,
                   rvals = seq(0, 100, by = 10),
                   mark_var = mark_var,
                   mark1 = "immune")
  },
  times = 10
)
```


# Border
```{r}
K_border_manual <- function(df,
                            rvals,
                            mark_var = NULL,
                            mark1 = NULL) {
  x <- df$x
  y <- df$y

  n <- length(x) # number of points
  
  xmin <- min(x)
  xmax <- max(x)
  ymin <- min(y)
  ymax <- max(y)
  
  
  width  <- xmax - xmin
  height <- ymax - ymin
  
  areaW <- width * height

  # pairwise 
  dx  <- outer(x, x, "-")
  dy  <- outer(y, y, "-")
  dij <- sqrt(dx^2 + dy^2)
  diag(dij) <- Inf

  # distance to boundary for each point (rectangle) 
  # b_i = min distance to any of the four sides
  b <- pmin(x - xmin, xmax - x, y - ymin, ymax - y)

  # intensity
  lambda_bar <- n / areaW

  Khat <- vapply(rvals, function(r) {
    interior_idx <- which(b >= r)       
    m <- length(interior_idx)
    if (m == 0) return(NA) # undefined when no interior points
        counts <- rowSums(dij[interior_idx, , drop = FALSE] <= r)
    sum(counts) / (lambda_bar * m)
  }, numeric(1))

  data.frame(
    r         = rvals,
    K_border  = Khat,
    theo_csr  = pi * rvals^2
  )
}
```


# Variance testing

```{r}

# takes about 5 minutes
result <- kamp(df, 
     rvals = seq(0, 100, by = 10),
     univariate = TRUE,
     mark_var = mark_var,
     mark1 = "immune",
     variance = TRUE)


result
```

```{r}
# Convert df to ppp object
win <- convexhull.xy(df$x, df$y)
ppp_obj <- ppp(df$x, df$y, window = win, marks = df[[marksvar]])
all_marks <- unique(marks(ppp_obj))

str(marks(ppp_obj))
npoints(ppp_obj)
length(marks(ppp_obj))


kamp_variance_Rcpp(ppp_obj,
                   rvals = seq(0, 100, by = 10),
                   correction = "trans",
                   mark1 = "immune")
                
```


```{r}
ids_test <- ovarian_df %>%
  group_by(sample_id) %>%
  filter(n() < 10000) %>% 
  ungroup() %>%
  distinct(sample_id) %>%
  slice_head(n = 10) %>%
  pull(sample_id)

rvals <- seq(0, 100, by = 10)

make_ppp <- function(df, mark_var) {
  win <- convexhull.xy(df$x, df$y)
  ppp(df$x, df$y, window = win, marks = df[[mark_var]])
}

mb_list <- lapply(ids_test, function(id) {
  df_sub <- ovarian_df %>% filter(sample_id == id)
  ppp_sub <- make_ppp(df_sub, mark_var)
  
  microbenchmark(
    kamp_pkg = kamp(df_sub, 
                    rvals=rvals, 
                    univariate=TRUE, 
                    mark_var=mark_var, 
                    mark1 = "immune", 
                    variance=TRUE),
    kamp_rcpp = kamp_variance_Rcpp(ppp_sub, 
                                   rvals=rvals, 
                                   correction="trans", 
                                   mark1 = "immune"),
    times = 2L
  )
})

# summarize medians per sample
meds <- do.call(rbind, lapply(seq_along(mb_list), function(k) {
  s <- summary(mb_list[[k]])
  data.frame(
    sample_id = ids_test[k],
    expr = s$expr,
    median_ms = s$median / 1e6
  )
}))

print(meds)



mb_df <- bind_rows(
  lapply(seq_along(mb_list), function(k) {
    dfk <- as.data.frame(mb_list[[k]])  
    dfk %>%
      mutate(
        sample_id = ids_test[k],
        method = as.character(expr),
        time_ms = time / 1e6
      ) %>%
      select(sample_id, method, time_ms)
  })
)

mb_wide_med <- mb_df %>%
  group_by(sample_id, method) %>%
  summarise(time_ms = median(time_ms), .groups = "drop") %>%
  pivot_wider(
    names_from  = method,
    values_from = time_ms
  )

mb_wide_sec <- mb_wide_med %>%
  mutate(
    kamp_rcpp = kamp_rcpp / 1000,
    kamp_pkg  = kamp_pkg  / 1000
  )

mb_wide_sec %>%
  mutate(
    speedup = kamp_pkg / kamp_rcpp
  )

boxplot(time_ms ~ method, data = mb_df, log = "y",
        ylab = "Runtime (ms, log scale)", xlab = "",
        main = "KAMP variance timing: kamp() vs kamp_variance_Rcpp()")

```


TODO:
- simulation study comparing results
  - show accuracy and computation time 
  - maybe tyoe 1 error?
- 
